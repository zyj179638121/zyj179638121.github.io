---
layout: post
title: "Guard"
date: 2015-12-16 16:08:17 +0800
comments: true
categories: 
---

当你查看这篇文章时，肯定是看到了代码中使用了guard特性，这样，这篇文章能解决你的疑惑
不过直接学习的也没关系，照样可以让你学会guard，开始吧。。。

guard特性是在Swift 2.0后推出的，所以请使用Xcode 7.X版本来编写代码

很多人都疑惑guard和if..else..到底有什么瓜葛，向下看，慢慢解释
<!--more-->
guard语句和if..else..语句有类似的地方，都是做判断处理
与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行
与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码
guard语句有且仅有else语句，当条件不成立时，执行else部分；当条件成立时，执行guard后面的代码
guard中声明的变量或者常量，在guard下面可以使用，但不能在else分支中使用
#### guard的使用

我们以今年高考为例，在进入考场时一般都会检查身份证和准考证，我们写这样一个方法：

	func checkUp(person: [String: String!]) {
    // 检查身份证
    guard let id = person["id"] else {
        print("没有携带身份证，禁止考试")
        return
    }

    // 检查准考证
    guard let examNumber = person["examNumber"] else {
        print("没有携带准考证，禁止考试")
        return
    }

    // 身份证和准考证齐全，可以进入考试
    print("学号：\(id)  准考证号：\(examNumber) 可以进行考试...")
}

	checkUp(["id": "xiaoze,maliya", "examNumber": "1302831992"])
详细看下面的解释(慢慢体会、慢慢体会、慢慢体会)，一共6句话，相信可以让你了然：

guard很奇怪，只有一个else分支。
guard没有条件成立的分支，确有条件不成立的分支。
其实是这样的：
当条件不成立的时候，会执行else分支，我们可以做一些执行转换语句，比如：return、break、continue或者throws
当条件成立的时候，会直接过掉guard语句，执行下面的代码
并且，我们在guard中声明的变量或者常量，在下面的区域内都可以使用。作用域看起来比较奇怪，但是非常实用
这段代码，比我们写if..else..会好一些，语法简洁，判断了我们想要判断的情况，并且也不需要再次强制解包的代码。




#### guard和if..else..的比较

if..else的使用

	func printInfo(age: Int?) {
    // 判断age不为空，并且判断是否大于等于0
    if age == nil || age < 0 {
        return
    }

    // 打印
    print(age!)
	}
在OC中，这是我们正常判断的一种写法，但是这种写法，存在一些小缺陷：

我们在检查一个不符合我们期望的值！而非检查我们期望的值！如果我们添加了太多这样的判断，我们的代码就会变得不好理解
如果前面都通过了，我们在使用参数的时候，还需要强制解包
可选绑定

	func printInfo2(age: Int?) {
    // 判断age不为空，并且大于0再打印
    if let age = age where age > 0 {

        // 如果条件满足，执行这里
        print(age)
    }

    // 如果条件值不符合，就会执行这里的代码
	}
这种写法虽然解决了第一种写法的问题，但却引入了新问题
把要写的代码放在了条件中，而不是之后，当条件很多的时候，代码可读性会非常的差

#### 通过guard解决问题

	func printInfo3(age: Int?) {
    // 判断age不为空，并且大于0再打印
    guard let age = age where age > 0 else {
        // 如果条件不成立，则执行这里，直接返回
        return
    }

    // 当条件符合的时候，执行这里，并且还不需要强制解包了
    print(age)
	}
#### guard的好处

是对你所期望的条件做检查，而不是非期望值
如果通过了条件判断，可选类型的变量在guard语句被调用的范围内会被自动的拆包，并且可选变量的作用域是函数内，非常方便
对你所不期望的情况早做检查，使得你写的函数更易读，更易维护


 

